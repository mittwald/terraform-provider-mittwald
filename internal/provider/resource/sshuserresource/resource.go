package sshuserresource

import (
	"context"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	mittwaldv2 "github.com/mittwald/api-client-go/mittwaldv2/generated/clients"
	"github.com/mittwald/api-client-go/mittwaldv2/generated/schemas/sshuserv2"
	"github.com/mittwald/terraform-provider-mittwald/internal/apiutils"
	"github.com/mittwald/terraform-provider-mittwald/internal/provider/providerutil"
	"github.com/mittwald/terraform-provider-mittwald/internal/provider/resource/common"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &Resource{}
var _ resource.ResourceWithImportState = &Resource{}

// New creates a new SSH user resource.
func New() resource.Resource {
	return &Resource{}
}

// Resource defines the resource implementation.
type Resource struct {
	client mittwaldv2.Client
}

// Metadata returns the resource type name.
func (r *Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ssh_user"
}

// Schema returns the resource schema.
func (r *Resource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	builder := common.AttributeBuilderFor("SSH user")
	resp.Schema = schema.Schema{
		MarkdownDescription: "This resource manages an SSH user for a project. SSH users can authenticate via password or SSH public keys and provide shell access to the project's file system.",

		Attributes: map[string]schema.Attribute{
			"id": builder.Id(),
			"project_id": schema.StringAttribute{
				MarkdownDescription: "The ID of the project the SSH user belongs to",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "A description for the SSH user",
				Required:            true,
			},
			"username": schema.StringAttribute{
				MarkdownDescription: "The generated username for SSH authentication. This is automatically generated by the API and cannot be changed.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"active": schema.BoolAttribute{
				MarkdownDescription: "Whether the SSH user is active. Defaults to `true`.",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(true),
			},
			"expires_at": schema.StringAttribute{
				MarkdownDescription: "The expiration date of the SSH user in RFC3339 format (e.g., `2024-12-31T23:59:59Z`). If not set, the user does not expire.",
				Optional:            true,
				Validators: []validator.String{
					&rfc3339Validator{},
				},
			},
			"public_keys": schema.SetNestedAttribute{
				MarkdownDescription: "Set of SSH public keys for authentication. Either `public_keys` or `password_wo` must be provided.",
				Optional:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							MarkdownDescription: "The SSH public key (e.g., `ssh-rsa AAAA... user@host`)",
							Required:            true,
						},
						"comment": schema.StringAttribute{
							MarkdownDescription: "A comment/label for the key (e.g., email address or identifier)",
							Required:            true,
						},
					},
				},
			},
			"password_wo": schema.StringAttribute{
				MarkdownDescription: "Password for SSH authentication. Either `password_wo` or `public_keys` must be provided. Maximum 72 characters.",
				Optional:            true,
				Sensitive:           true,
				WriteOnly:           true,
			},
			"password_wo_version": schema.Int64Attribute{
				MarkdownDescription: "Version of the password. You must increment this value whenever the password is changed to trigger an update.",
				Optional:            true,
			},
			"created_at": schema.StringAttribute{
				MarkdownDescription: "The creation timestamp of the SSH user in RFC3339 format",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

// Configure configures the resource with the provider client.
func (r *Resource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	r.client = providerutil.ClientFromProviderData(req.ProviderData, &resp.Diagnostics)
}

// Create creates a new SSH user.
func (r *Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data ResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get password from config (write-only attribute)
	var passwordWO types.String
	resp.Diagnostics.Append(req.Config.GetAttribute(ctx, path.Root("password_wo"), &passwordWO)...)
	if resp.Diagnostics.HasError() {
		return
	}

	sshUser := providerutil.
		Try[*sshuserv2.SshUser](&resp.Diagnostics, "API error while creating SSH user").
		DoValResp(r.client.SSHSFTPUser().CreateSSHUser(ctx, data.ToCreateRequest(ctx, &resp.Diagnostics, passwordWO)))

	if resp.Diagnostics.HasError() {
		return
	}

	data.ID = types.StringValue(sshUser.Id)

	// Wait briefly to allow the API to reflect the new SSH user before reading it back
	time.Sleep(100 * time.Millisecond)

	readCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	resp.Diagnostics.Append(r.read(readCtx, &data)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Read reads the SSH user state.
func (r *Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	resp.Diagnostics.Append(r.read(readCtx, &data)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// read fetches the SSH user from the API with polling for eventual consistency.
func (r *Resource) read(ctx context.Context, data *ResourceModel) (res diag.Diagnostics) {
	sshUser := providerutil.
		Try[*sshuserv2.SshUser](&res, "API error while fetching SSH user").
		DoVal(apiutils.PollRequest(ctx, apiutils.PollOpts{}, r.client.SSHSFTPUser().GetSSHUser, data.ToGetRequest()))

	if res.HasError() {
		return
	}

	res.Append(data.FromAPIModel(ctx, sshUser)...)

	return
}

// Update updates an existing SSH user.
func (r *Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var planData, stateData ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Get password from config (write-only attribute)
	var passwordWO types.String
	resp.Diagnostics.Append(req.Config.GetAttribute(ctx, path.Root("password_wo"), &passwordWO)...)
	if resp.Diagnostics.HasError() {
		return
	}

	providerutil.
		Try[any](&resp.Diagnostics, "API error while updating SSH user").
		DoResp(r.client.SSHSFTPUser().UpdateSSHUser(ctx, planData.ToUpdateRequest(ctx, &resp.Diagnostics, &stateData, passwordWO)))

	if resp.Diagnostics.HasError() {
		return
	}

	// Preserve password_wo_version from plan
	stateData.PasswordWOVersion = planData.PasswordWOVersion

	readCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	resp.Diagnostics.Append(r.read(readCtx, &stateData)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &stateData)...)
}

// Delete deletes an SSH user.
func (r *Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	providerutil.
		Try[any](&resp.Diagnostics, "API error while deleting SSH user").
		DoResp(r.client.SSHSFTPUser().DeleteSSHUser(ctx, data.ToDeleteRequest()))
}

// ImportState imports an existing SSH user.
func (r *Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
